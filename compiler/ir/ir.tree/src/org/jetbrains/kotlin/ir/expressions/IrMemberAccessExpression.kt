/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.expressions

import org.jetbrains.kotlin.ir.LocationTracker
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSymbolOwner
import org.jetbrains.kotlin.ir.declarations.IrValueParameter
import org.jetbrains.kotlin.ir.symbols.IrBindableSymbol
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrFakeOverrideSymbolBase
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.resolveFakeOverrideMaybeAbstractOrFail
import org.jetbrains.kotlin.ir.util.transformInPlace
import org.jetbrains.kotlin.ir.visitors.IrElementTransformer
import org.jetbrains.kotlin.ir.visitors.IrElementVisitor

// This class is not autogenerated to for the sake refactoring IR parameters - see KT-68003.
// However, it must be kept in sync with [org.jetbrains.kotlin.ir.generator.IrTree.memberAccessExpression].
abstract class IrMemberAccessExpression<S : IrSymbol> : IrDeclarationReference() {
    abstract override val symbol: S

    abstract var origin: IrStatementOrigin?

    protected abstract val typeArguments: Array<IrType?>


    // Dummy values. Real ones will be provided in subsequent commits.
    var targetContextParameterCount: Int = -1
        private set
    var targetHasDispatchReceiver: Boolean = false
        private set
    var targetHasExtensionReceiver: Boolean = false
        private set

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    internal fun initializeTargetShapeFromSymbol() {
        @Suppress("UNCHECKED_CAST")
        val target = (symbol as IrBindableSymbol<*, IrSymbolOwner>).getRealOwner()
        when (target) {
            is IrFunction -> {
                initializeTargetShapeExplicitly(
                    target.dispatchReceiverParameter != null,
                    target.extensionReceiverParameter != null,
                    target.contextReceiverParametersCount,
                    target.valueParameters.size - target.contextReceiverParametersCount,
                )
            }
            is IrProperty -> {
                val hasDispatchReceiver: Boolean
                val hasExtensionReceiver: Boolean

                val accessor = when (this) {
                    is IrPropertyReference -> (getter ?: setter)?.getRealOwner()
                    is IrLocalDelegatedPropertyReference -> getter.owner
                    else -> error("Unexpected reference to a property from $this")
                }
                if (accessor != null) {
                    hasDispatchReceiver = accessor.dispatchReceiverParameter != null
                    hasExtensionReceiver = accessor.extensionReceiverParameter != null
                } else {
                    val realProperty = target.resolveFakeOverrideMaybeAbstractOrFail()
                    if (realProperty.origin == IrDeclarationOrigin.IR_EXTERNAL_JAVA_DECLARATION_STUB
                        || realProperty.origin == IrDeclarationOrigin.SYNTHETIC_JAVA_PROPERTY_DELEGATE
                    ) {
                        hasDispatchReceiver = !realProperty.backingField!!.isStatic
                        hasExtensionReceiver = false
                    } else {
                        error("Cannot infer the shape of property $symbol, please specify it explicitly")
                    }
                }

                initializeTargetShapeExplicitly(
                    hasDispatchReceiver,
                    hasExtensionReceiver,
                    0,
                    0,
                )
            }
        }
    }

    private fun <S : IrBindableSymbol<*, D>, D : IrSymbolOwner> S.getRealOwner(): D {
        var symbol = this
        while (symbol is IrFakeOverrideSymbolBase<*, *, *>) {
            @Suppress("UNCHECKED_CAST")
            symbol = symbol.originalSymbol as S
        }
        return symbol.owner
    }

    fun initializeTargetShapeExplicitly(
        hasDispatchReceiver: Boolean,
        hasExtensionReceiver: Boolean,
        contextParameterCount: Int,
        regularParameterCount: Int,
    ) {
        targetHasDispatchReceiver = hasDispatchReceiver
        targetHasExtensionReceiver = hasExtensionReceiver
        targetContextParameterCount = contextParameterCount
        if (valueArguments === EMPTY_ARGUMENTS) {
            valueArguments = arrayOfNulls(regularParameterCount + contextParameterCount)
        }
    }

    var dispatchReceiver: IrExpression? = null
        set(value) {
            registerCaller()
            checkTargetHasReceiver(field, value, targetHasDispatchReceiver, IrFunction::dispatchReceiverParameter)
            field = value
        }

    var extensionReceiver: IrExpression? = null
        set(value) {
            registerCaller()
            checkTargetHasReceiver(field, value, targetHasExtensionReceiver, IrFunction::extensionReceiverParameter)
            field = value
        }

    private fun checkTargetHasReceiver(
        oldValue: IrExpression?,
        newValue: IrExpression?,
        callSiteHasReceiver: Boolean,
        getTargetParameter: IrFunction.() -> IrValueParameter?,
    ) {
        LocationTracker.initialize()

        val wasBefore = oldValue != null
        val isNow = newValue != null
        if (wasBefore == isNow) {
            return
        }

        if (!isNow) {
            return
        }

        if (isNow && !callSiteHasReceiver) {
            if (symbol.isBound) {
                val function = (symbol.owner as? IrFunction) ?: return
                val nowHasParameter = getTargetParameter(function) != null
                if (nowHasParameter) {
                    LocationTracker.recordStackTrace(LocationTracker.argumentAddedForParameterInsertedAfterCreation, 1)
                    return
                }
            }

            LocationTracker.recordStackTrace(LocationTracker.argumentAddedForNonExistingParameter, 1)
        }
    }

    private var valueArguments: Array<IrExpression?> = EMPTY_ARGUMENTS

    protected fun updateTargetSymbol() {
        registerCaller()
        initializeTargetShapeFromSymbol()
    }

    private fun registerCaller() {
        if (symbol.isBound) {
            (symbol.owner as? IrFunction)?.anyCallHasBeenCreated = true
        }
    }

    val valueArgumentsCount: Int
        get() {
            registerCaller()
            return valueArguments.size
        }

    fun getValueArgument(index: Int): IrExpression? {
        registerCaller()
        checkArgumentSlotAccess("value", index, valueArguments.size)
        return valueArguments[index]
    }

    fun putValueArgument(index: Int, valueArgument: IrExpression?) {
        registerCaller()
        checkArgumentSlotAccess("value", index, valueArguments.size)
        valueArguments[index] = valueArgument
    }


    val typeArgumentsCount: Int
        get() = typeArguments.size

    fun getTypeArgument(index: Int): IrType? {
        checkArgumentSlotAccess("type", index, typeArguments.size)
        return typeArguments[index]
    }

    fun putTypeArgument(index: Int, type: IrType?) {
        checkArgumentSlotAccess("type", index, typeArguments.size)
        typeArguments[index] = type
    }

    override fun <D> acceptChildren(visitor: IrElementVisitor<Unit, D>, data: D) {
        dispatchReceiver?.accept(visitor, data)
        extensionReceiver?.accept(visitor, data)
        valueArguments.forEach { it?.accept(visitor, data) }
    }

    override fun <D> transformChildren(transformer: IrElementTransformer<D>, data: D) {
        dispatchReceiver = dispatchReceiver?.transform(transformer, data)
        extensionReceiver = extensionReceiver?.transform(transformer, data)
        valueArguments.transformInPlace(transformer, data)
    }

    companion object {
        private val EMPTY_ARGUMENTS = emptyArray<IrExpression?>()
    }
}