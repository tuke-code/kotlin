/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.declarations

import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.expressions.IrBody
import org.jetbrains.kotlin.ir.symbols.IrFunctionSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.render
import org.jetbrains.kotlin.ir.util.transformIfNeeded
import org.jetbrains.kotlin.ir.util.transformInPlace
import org.jetbrains.kotlin.ir.visitors.IrElementTransformer
import org.jetbrains.kotlin.ir.visitors.IrElementVisitor

// This class is not autogenerated to for the sake refactoring IR parameters - see KT-68003.
// However, it must be kept in sync with [org.jetbrains.kotlin.ir.generator.IrTree.function].
sealed class IrFunction : IrDeclarationBase(), IrPossiblyExternalDeclaration, IrDeclarationWithVisibility, IrTypeParametersContainer,
    IrSymbolOwner, IrDeclarationParent, IrReturnTarget, IrMemberWithContainerSource, IrMetadataSourceOwner {
    @ObsoleteDescriptorBasedAPI
    abstract override val descriptor: FunctionDescriptor

    abstract override val symbol: IrFunctionSymbol

    abstract var isInline: Boolean

    abstract var isExpect: Boolean

    abstract var returnType: IrType


    private val _parameters: MutableList<IrValueParameter> = ArrayList()

    /**
     * All value parameters.
     *
     * Parameters must follow this order:
     *
     * [[dispatch receiver, context parameters, extension receiver, regular parameters]].
     */
    @OptIn(DelicateIrParameterIndexSetter::class)
    var parameters: List<IrValueParameter>
        get() = _parameters
        set(value) {
            val parameters = _parameters
            for (parameter in parameters) {
                parameter.index = -1
                parameter.indexNew = -1
            }

            var newContextParametersCount = 0
            var oldIndex = 0
            var lastKind: IrParameterKind? = null
            for ((index, parameter) in value.withIndex()) {
                val kind = parameter._kind
                require(kind != null) { "Kind must be set explicitly when adding a parameter" }
                if (lastKind != null) {
                    require(kind >= lastKind) {
                        "Invalid order of function parameters: $kind is placed after ${lastKind}.\n" +
                                "Parameters must follow a strict order: " +
                                "[dispatch receiver, context parameters, extension receiver, regular parameters]."
                    }

                    if (!kind.canHaveMultiple) {
                        require(kind != lastKind) { "Function may have only one $kind parameter" }
                    }
                }

                parameter.indexNew = index
                parameter.index = when (kind) {
                    IrParameterKind.DispatchReceiver, IrParameterKind.ExtensionReceiver -> -1
                    IrParameterKind.ContextParameter, IrParameterKind.RegularParameter -> oldIndex++
                }

                if (kind == IrParameterKind.ExtensionReceiver) {
                    newContextParametersCount++
                }

                lastKind = kind
            }

            parameters.clear()
            parameters.addAll(value)
            _contextReceiverParametersCount = newContextParametersCount
        }

    /**
     * A value parameter of kind [IrParameterKind.DispatchReceiver], if present.
     *
     * ##### This is a deprecated API!
     * Instead, use [parameters] directly. A drop-in replacement:
     * ```
     * parameters.firstOrNull { it.kind == IrParameterKind.DispatchReceiver }
     * ```
     *
     * Details on the API migration: KT-68003
     */
    var dispatchReceiverParameter: IrValueParameter?
        get() = _parameters.getOrNull(0)?.takeIf { it.kind == IrParameterKind.DispatchReceiver }
        set(value) {
            setReceiverParameter(IrParameterKind.DispatchReceiver, value)
        }

    /**
     * A value parameter of kind [IrParameterKind.ExtensionReceiver], if present.
     *
     * ##### This is a deprecated API!
     * Instead, use [parameters] directly. A drop-in replacement:
     * ```
     * parameters.firstOrNull { it.kind == IrParameterKind.ExtensionReceiver }
     * ```
     *
     * Details on the API migration: KT-68003
     */
    var extensionReceiverParameter: IrValueParameter?
        get() = _parameters.firstOrNull { it.kind == IrParameterKind.ExtensionReceiver }
        set(value) {
            setReceiverParameter(IrParameterKind.ExtensionReceiver, value)
        }

    @OptIn(DelicateIrParameterIndexSetter::class)
    private fun setReceiverParameter(kind: IrParameterKind, value: IrValueParameter?) {
        val parameters = _parameters
        var index = parameters.indexOfFirst { it.kind == kind }
        if (index >= 0) {
            val old = parameters[index]
            old.index = -1
            old.indexNew = -1
            old._kind = null

            if (value != null) {
                parameters[index] = value
            } else {
                parameters.removeAt(index)
            }
        } else {
            if (value != null) {
                index = parameters.indexOfLast { it.kind < kind } + 1
                parameters.add(index, value)
            } else {
                // nothing
            }
        }

        if (value != null) {
            value.index = -1
            value.indexNew = index
            value.kind = kind
        }
    }

    private var _contextReceiverParametersCount: Int = 0

    /**
     * The number of context parameters in the [parameters] and [valueParameters] lists.
     *
     * There first `contextReceiverParametersCount` parameters in [valueParameters] are [IrParameterKind.ContextParameter],
     * the following are [IrParameterKind.RegularParameter].
     *
     * ##### This is a deprecated API!
     * Instead, use [parameters] directly. A drop-in replacement:
     * ```
     * parameters.count { it.kind == IrParameterKind.ContextParameter }
     * ```
     *
     * Details on the API migration: KT-68003
     */
    var contextReceiverParametersCount: Int
        get() = _contextReceiverParametersCount
        set(value) {
            if (value == _contextReceiverParametersCount) {
                return
            }

            replaceRegularAndExtensionParameters(null, value)
            _contextReceiverParametersCount = value
        }

    /**
     * A filtered list of [parameters], that contains only
     * [IrParameterKind.ContextParameter] and [IrParameterKind.DispatchReceiver] parameters.
     * Setting this property, likewise, only replaces those kinds of parameters with the provided list,
     * leaving dispatch and extension receiver intact.
     *
     * ##### This is a deprecated API!
     * Use [parameters] instead. A drop-in replacement:
     * ```
     * parameters.filter { it.kind == IrParameterKind.RegularParameter || it.kind == IrParameterKind.ContextParameter }
     * ```
     *
     * Details on the API migration: KT-68003
     */
    var valueParameters: List<IrValueParameter>
        get() = _parameters.filter { it.kind == IrParameterKind.RegularParameter || it.kind == IrParameterKind.ContextParameter }
        set(value) {
            replaceRegularAndExtensionParameters(value, _contextReceiverParametersCount)
        }

    @OptIn(DelicateIrParameterIndexSetter::class)
    private fun replaceRegularAndExtensionParameters(newValueParameters: List<IrValueParameter>?, newContextParametersCount: Int) {
        val parameters = _parameters

        // Temporarily remove extension receiver, if present.
        // It will be re-added later, after all context parameters.
        var extensionReceiver = parameters
            .indexOfFirst { it.kind == IrParameterKind.ExtensionReceiver }
            .takeUnless { it == -1 }
            ?.let { parameters.removeAt(it) }

        var remainingContextParams = newContextParametersCount
        var srcIndex = 0
        var dstIndex = 0
        while (dstIndex <= parameters.size || srcIndex < (newValueParameters?.size ?: 0)) {
            val old = parameters.getOrNull(dstIndex)

            if (old?._kind == IrParameterKind.DispatchReceiver) {
                dstIndex++
                continue
            }

            if (extensionReceiver != null && (remainingContextParams == 0 || dstIndex == parameters.size)) {
                parameters.add(dstIndex++, extensionReceiver)
                extensionReceiver = null
                continue
            }

            if (old != null) {
                old.index = -1
                old.indexNew = -1
                old._kind = null
            }

            val new = if (newValueParameters != null)
                newValueParameters.getOrNull(srcIndex)
            else old
            if (new != null) {
                require(!new._kind.let { it == IrParameterKind.DispatchReceiver || it == IrParameterKind.ExtensionReceiver }) {
                    "Adding a value parameter ${new.render()} to function ${this.render()}, when it's already present as a receiver.\n" +
                            "This operation is not supported by the old<->new parameter API bridge."
                }

                new.index = srcIndex
                new.indexNew = dstIndex
                new._kind = if (remainingContextParams-- > 0) IrParameterKind.ContextParameter else IrParameterKind.RegularParameter

                if (old != null) {
                    parameters[dstIndex] = new
                } else {
                    parameters.add(dstIndex, new)
                }

                srcIndex++
            }

            if (new == null && dstIndex < parameters.size) {
                parameters.removeAt(dstIndex)
            } else {
                dstIndex++
            }
        }
    }


    abstract var body: IrBody?

    override fun <D> acceptChildren(visitor: IrElementVisitor<Unit, D>, data: D) {
        typeParameters.forEach { it.accept(visitor, data) }
        parameters.forEach { it.accept(visitor, data) }
        body?.accept(visitor, data)
    }

    override fun <D> transformChildren(transformer: IrElementTransformer<D>, data: D) {
        typeParameters = typeParameters.transformIfNeeded(transformer, data)
        _parameters.transformInPlace(transformer, data)
        body = body?.transform(transformer, data)
    }
}

